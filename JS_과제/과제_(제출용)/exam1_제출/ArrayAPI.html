<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Array API 함수 용례 정리</title>
<link rel="stylesheet" href="./common.css">
</head>
<body>
    <h1>Array api</h1>
    <div>
        <ul>
            <li>
                <p class="title2">1. 배열 만들기</p>
                <p class="desc">: 배열을 생성할 때 사용하는 리스트 형태의 객체이다.</p>
                <pre>
                    <code>
let fruits = ["사과", "바나나"];
console.log(fruits.length); 
// 2
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 2. 인덱스로 배열의 항목에 접근하기 </p>
                <pre>
                    <code>
let first = fruits[0]; // 사과
let last = fruits[fruits.length - 1]; 
// 바나나
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 3. 배열의 항목들을 순환하며 처리하기 </p>
                <pre>
                    <code>
fruits.forEach(function (fruit, index) {
    console.log(fruit, index);
})
// 사과 0
// 바나나 1                    
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 4. 배열 끝에 항목 추가하기 push() </p>
                <pre>
                    <code>
let newEndLength = fruits.push("오렌지");
console.log(newEndLength); // 3
console.log(fruits); // ["사과", "바나나", "오렌지"]
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 5. 배열 끝에서부터 항목 제거하기 pop() </p>
                <pre>
                    <code>
let lastPop = fruits.pop(); // 끝에 있던 '오렌지'를 제거한다.
console.log(lastPop); // 오렌지
console.log(fruits); // ["사과", "바나나"]
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 6. 배열 앞에서부터 항목 제거하기 shift() </p>
                <pre>
                    <code>
let firstShift = fruits.shift(); // 제일 앞의 '사과'를 제거한다.
console.log(firstShift); // 사과
console.log(fruits); // ["바나나"]                
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 7. 배열 앞에 항목 추가하기 unshift() </p>
                <pre>
                    <code>
let newFirstLength = fruits.unshift("딸기"); // 제일 앞에 추가한다.
console.log(newFirstLength); // 2 -> length를 돌려주는건가?
console.log(fruits) // ["딸기", "바나나"]
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 8. 배열 안 항목의 인덱스 찾기 indexOf() </p>
                <div>
                    <span class="hl">반환 값</span> <br>
                    - 배열에서 지정된 요소를 찾을 수 있는 첫 번째 인덱스를 반환한다. (최초의 인덱스) <br>
                    - 존재하지 않으면 -1을 반환. <br>
                    - indexOf()는 엄격한 동등성(===)을 사용하여 검색한다.
                </div>
                <pre>
                    <code>
let 바나나는몇번째일까요 = fruits.indexOf("바나나");
console.log(바나나는몇번째일까요); // 1 (index)
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 9. 인덱스 위치에 있는 항목 제거하기 splice() </p>
                <div>
                    - 배열의 기존 요소를 삭제 또는 교체하거나 새로운 요소를 추가하여 배열의 내용을 변경한다. <br>
                    - [!] 원 배열인 myCart의 값이 변하게 된다. <br><br>
                    <span class="hl">구문</span> <br>
                    - arr.splice(시작인덱스, 삭제할요소수, 추가할요소1, 추가할요소2, ...) <br>
                    <span class="hl">반환 값</span> <br>
                    - 제거한 요소를 담은 배열. 아무 값도 제거하지 않았으면 빈 배열 반환. <br>
                </div>
                <p class="title3">예제1) 하나도 제거하지 않고, 2번 인덱스에 "부채살" 추가</p>  
                <pre>
                    <code> 
var myCart = ["등심", "두부", "버섯", "양파", "소금", "아스파라거스"];
var 시작인덱스 = 2;
var 삭제할요소수 = 0;
var removed = myCart.splice(시작인덱스, 삭제할요소수, "부채살"); 
// ["등심", "두부", "부채살", "버섯", "양파", "소금", "아스파라거스"]
console.log(myCart);
console.log(removed); // removed is []
                    </code>
                </pre>
                <p class="title3">예제2) 하나도 제거하지 않고, 2번 인덱스에 "와사비", "마늘" 추가</p>  
                <pre>
                    <code>  
var removed = myCart.splice(시작인덱스, 삭제할요소수, "와사비", "마늘");
// ["등심", "두부", "와사비", "마늘", "부채살", "버섯", "양파", "소금", "아스파라거스"]
console.log(myCart);
                    </code>
                </pre>
                <p class="title3">예제3) 3번 인덱스에서 요소 1개 제거</p>  
                <pre>
                    <code> 
var removed = myCart.splice(3, 1);
console.log(removed); // removed is ["마늘"]
console.log(myCart); // ["등심", "두부", "와사비", "부채살", "버섯", "양파", "소금", "아스파라거스"]
                    </code>
                </pre>
                <p class="title3"> 예제4) 5번 인덱스에서 요소 3개 제거하고 "양배추" 추가</p>  
                <pre>
                    <code> 
var removed = myCart.splice(5, 3, "양배추");
console.log(removed); // removed is ["양파", "소금", "아스파라거스"]
console.log(myCart); // ["등심", "두부", "와사비", "부채살", "버섯", "양배추"]
                    </code>
                </pre>
                <p class="title3">예제5) 2번 인덱스를 포함해서 이후의 '모든 요소 제거'</p>  
                <pre>
                    <code> 
var removed = myCart.splice(2);
console.log(removed); // removed is ["와사비", "부채살", "버섯", "양배추"]
console.log(myCart); // ["등심", "두부"]
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 10. 배열 복사하기 slice()</p>
                <div>
                    - 어떤 배열의 '처음' 부터 '끝'까지(끝은 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환.<br>
                    - 원본 배열은 변하지 않는다. <br>
                    <span class="hl">구문</span> <br>
                    - arr.splice(시작인덱스, 삭제할요소수, 추가할요소1, 추가할요소2, ...) <br>
                    <span class="hl">반환 값</span> <br>
                    - 제거한 요소를 담은 배열. 아무 값도 제거하지 않았으면 빈 배열 반환. <br>
                </div>
                <pre>
                    <code>
let music = ["hiphop", "jazz", "rock", "classic", "rnb", "funk", "pop"]

console.log(music.slice()); 
// ["hiphop", "jazz", "rock", "classic", "rnb", "funk", "pop"]

console.log(music.slice(3, 6)); // index 3, 4, 5
// ["classic", "rnb", "funk"]

console.log(music.slice(1, 3)); // index 1, 2 
// [jazz", "rock"]

console.log(music.slice(1)); // index 1 부터 ~
// ["jazz", "rock", "classic", "rnb", "funk", "pop"]
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 11. 배열의 순서를 거꾸로 만들기 reverse() </p>
                <div>
                    <span class="hl">반환 값</span> <br>
                    - 정렬한 배열. 원본 배열이 변경됨. 복사본이 아님. <br>
                </div>
                <pre>
                    <code>
const array1 = ["one", "two", "three"];
const reversed = array1.reverse();
console.log(reversed); // ["three", "two", "one"]
console.log(array1); // ["three", "two", "one"] 원본 배열도 변경된다.
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 12. 정렬하기 sort() </p>
                <div>
                    <span class="hl">구문</span><br>
                    - arr.sort( [compareFucntion] ) <br>
                    <span class="hl">매개변수 : compareFunction </span><br>
                    - 정렬 순서를 정의하는 함수이다. 생략하면 배열은 각 요소의 문자열 변환에 따라 각 문자의 뉴이 코드 포인트 값에 따라 정렬된다. <br>
                    <span class="hl">반환 값</span><br>
                    - 정렬한 배열. 원 배열이 정렬된다. 복사본이 아님.
                </div>
                <pre>
                    <code>
const array1 = ["one", "two", "three"];
const reversed = array1.reverse();
console.log(reversed); // ["three", "two", "one"]
console.log(array1); // ["three", "two", "one"] 원본 배열도 변경된다.

var numbers = [4, 20, 52, 512, 1, 32];
console.log(numbers.sort()); // [1, 20, 32, 4, 512, 52]
// 매개변수가 되는 compareFunction이 제공되지 않으면 요소를 문자열로 변환하고 유니코드 순으로 배열됨. 
// 원하는 결과값이 나오지 않을 수 있음.
                    </code>
                </pre>
                <pre>
                    <code>
sort 메소드는 클로저와 함께 사용할 수 있다.
numbers.sort(function(a, b) {
    return a - b; // 오름차순으로 정렬된다.
});
console.log(numbers);
// [1, 4, 20, 32, 52, 512]
                    </code>
                </pre>
                <p class="title3">[참고] 매개변수로 오는 compare함수의 형식</p>
                <pre>
                    <code>
function compare(a, b) {
    if( a가 b보다 작을 경우 ) {
        return -1; // a가 먼저 온다.
    }
    if( a가 b보다 클 경우 ) {
        return 1; // b가 먼저 온다.
    }
    // a must be equal to b
    return 0; // a와 b를 서로에 대해 변경하지 않는다.
}

// map을 사용하여 정리하기도 한다. 
// compareFunction이 여러번 호출되는 경우 높은 오버헤드가 발생할 수 있기 때문.

                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 13. 인자로 주어진 배열이나 값들을 기존의 배열에 합쳐주는 concat() </p>
                <div>
                    - 기존의 원본 배열은 변경되지 않는다.<br>
                    <span class="hl">매개변수</span> <br>
                    - 배열 또는 값, 인자를 생략할 경우 기존배열의 얕은 복사본을 반환. <br>
                    <span class="hl">반환 값</span> <br>
                    - 추가된 새로운 배열을 반환한다. <br>
                </div>
                <pre>
                    <code>
const array2 = ["가", "나", "다"];
const array3 = ["라", "마", "바"];
const array4 = ["사", "아", "자"];
const concatArray = array2.concat(array3, array4);

console.log(concatArray); // ["가", "나", "다", "라", "마", "바"]
console.log(array2); // ["가", "나", "다"] 원본은 손상되지 않는다.
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 14. toString() </p>
                <div>
                    <span class="hl">반환 값</span> <br>
                    - 배열을 문자열로 반환한다. <br>
                </div>
                <pre>
                    <code>
var array5 = ["가", "나", "다", "라"];
var myVar = array5.toString();
console.log(myVar); // 가, 나, 다, 라
                    </code>
                </pre>
            </li>
            <li>
                <p class="title2"> 15. Array to String join() </p>
                <div>
                    - join을 통해 구분자를 넣어주면 Array가 String으로 전환된다. <br>
                </div>
                <pre>
                    <code>
var names = ["judy", "kiki", "brown"];

// 보통의 방식
console.log(names[0] + ' ' +names[1]+ ' '+names[2]); // judy kiki brown

// join 방식
console.log(names.join(" ")); // judy kiki brown
console.log(names.join("-")); // judy-kiki-brown
console.log(names.join("")); // judykikibrown

// default separator : comma (,)
console.log(names.join()); // judy,kiki,brown

// 다른 메서드와 함께 사용한 예제
var name = "song heemyun";
var upper = name.split(" ") // ["song", "heemyun"]
            .map(x => x.charAt(0).toUpperCase() + x.slice(1)) // 배열을 하나씩 선택해서 0번째 문자를 대문자로 + 문자를 1번째 부터 복사해옴.
            .join(" "); // 공백을 포함하여 문자열(Strnig)로 반환하라.
console.log(upper); // Song Heemyun
                    </code>
                </pre>
            </li>
            <script>
                var names = ["judy", "kiki", "brown"];

                // 보통의 방식
                console.log(names[0] + ' ' + names[1] + ' ' + names[2]); // judy kiki brown

                // join 방식
                console.log(names.join(" ")); // judy kiki brown
                console.log(names.join("-")); // judy-kiki-brown
                console.log(names.join("")); // judykikibrown

                // default separator : comma (,)
                console.log(names.join()); // judy,kiki,brown

                // 다른 메서드와 함께 사용한 예제
                var name = "song heemyun";
                var upper = name.split(" ") // ["song", "heemyun"]
                            .map(x => x.charAt(0).toUpperCase() + x.slice(1)) // 배열을 하나씩 선택해서 0번째 문자를 대문자로 + 문자를 1번째 부터 복사해옴.
                            .join(" "); // 공백을 포함하여 문자열(Strnig)로 반환하라.
                console.log(upper); // Song Heemyun

            </script>
        </ul>
    </div>

    <script>
        // 1. 배열 만들기
        let fruits = ["사과", "바나나"];
        console.log(fruits.length); 
        // 2


        // 2. 인덱스로 배열의 항목에 접근하기
        let first = fruits[0]; // 사과
        let last = fruits[fruits.length - 1]; 
        // 바나나


        // 3. 배열의 항목들을 순환하며 처리하기
        fruits.forEach(function (fruit, index) {
            console.log(fruit, index);
        })
        // 사과 0
        // 바나나 1

        
        // 4. join
        var avengers = ["Iron man", "Hulk", "Thor", "Black widow"];
        console.log(avengers.join(" ")); // Iron man Hulk Thor Black widow
        console.log(avengers.join(", ")); //Iron man, Hulk, Thor, Black widow
        console.log(avengers.join(" - ")); // Iron man - Hulk - Thor - Black widow
        console.log(avengers.join(" 와(과) ")); // Iron man 와(과) Hulk 와(과) Thor 와(과) Black widow

        /*
            join을 통해 구분자를 넣어주면 Array가 String으로 전환된다. 
        */

        // 5. 배열 끝에 항목 추가하기 push()
        let newEndLength = fruits.push("오렌지");
        console.log(newEndLength); // 3
        console.log(fruits); // ["사과", "바나나", "오렌지"]

        
        // 6. 배열 끝에서부터 항목 제거하기 pop()
        let lastPop = fruits.pop(); // 끝에 있던 '오렌지'를 제거한다.
        console.log(lastPop); // 오렌지
        console.log(fruits); // ["사과", "바나나"]


        // 7. 배열 앞에서부터 항목 제거하기 shift()
        let firstShift = fruits.shift(); // 제일 앞의 '사과'를 제거한다.
        console.log(firstShift); // 사과
        console.log(fruits); // ["바나나"]

        
        // 8. 배열 앞에 항목 추가하기 unshift()
        let newFirstLength = fruits.unshift("딸기"); // 제일 앞에 추가한다.
        console.log(newFirstLength); // 2 -> length를 돌려주는건가?
        console.log(fruits) // ["딸기", "바나나"]


        // 9. 배열 안 항목의 인덱스 찾기 indexOf()
        // 반환 값
        // - 배열에서 지정된 요소를 찾을 수 있는 첫 번째 인덱스를 반환한다. (최초의 인덱스)
        // - 존재하지 않으면 -1을 반환.
      
        // indexOf()는 엄격한 동등성(===)을 사용하여 검색한다.
        fruits.push("망고")
        console.log(fruits); // ["딸기", "바나나", "망고"]
        
        let 바나나는몇번째일까요 = fruits.indexOf("바나나");
        console.log(바나나는몇번째일까요); // 1 (index)
    
       
        // 10. 인덱스 위치에 있는 항목 제거하기 splice()
        // 배열의 기존 요소를 삭제 또는 교체하거나 새로운 요소를 추가하여 배열의 내용을 변경한다.
        // [!] 원 배열인 myCart의 값이 변하게 된다. 
        // 구문
        // - arr.splice(시작인덱스, 삭제할요소수, 추가할요소1, 추가할요소2, ...)
        // 반환 값
        // - 제거한 요소를 담은 배열. 아무 값도 제거하지 않았으면 빈 배열 반환.
        
        // 하나도 제거하지 않고, 2번 인덱스에 "부채살" 추가
        var myCart = ["등심", "두부", "버섯", "양파", "소금", "아스파라거스"];
        var 시작인덱스 = 2;
        var 삭제할요소수 = 0;
        var removed = myCart.splice(시작인덱스, 삭제할요소수, "부채살"); 
        // ["등심", "두부", "부채살", "버섯", "양파", "소금", "아스파라거스"]
        console.log(myCart);
        console.log(removed); // removed is []

        // 하나도 제거하지 않고, 2번 인덱스에 "와사비", "마늘" 추가
        var removed = myCart.splice(시작인덱스, 삭제할요소수, "와사비", "마늘");
        // ["등심", "두부", "와사비", "마늘", "부채살", "버섯", "양파", "소금", "아스파라거스"]
        console.log(myCart);

        // 3번 인덱스에서 요소 1개 제거
        var removed = myCart.splice(3, 1);
        console.log(removed); // removed is ["마늘"]
        console.log(myCart); // ["등심", "두부", "와사비", "부채살", "버섯", "양파", "소금", "아스파라거스"]

        // 5번 인덱스에서 요소 3개 제거하고 "양배추" 추가
        var removed = myCart.splice(5, 3, "양배추");
        console.log(removed); // removed is ["양파", "소금", "아스파라거스"]
        console.log(myCart); // ["등심", "두부", "와사비", "부채살", "버섯", "양배추"]

        // 2번 인덱스를 포함해서 이후의 '모든 요소 제거'
        var removed = myCart.splice(2);
        console.log(removed); // removed is ["와사비", "부채살", "버섯", "양배추"]
        console.log(myCart); // ["등심", "두부"]

        

        // 11. 배열 복사하기 slice()
        // 어떤 배열의 '처음' 부터 '끝'까지(끝은 미포함)에 대한 얕은 복사본을 새로운 배열 객체로 반환.
        // 원본 배열은 변하지 않는다.
        let music = ["hiphop", "jazz", "rock", "classic", "rnb", "funk", "pop"]
        console.log(music.slice()); 
        // ["hiphop", "jazz", "rock", "classic", "rnb", "funk", "pop"]
        console.log(music.slice(3, 6)); // index 3, 4, 5
        // ["classic", "rnb", "funk"]
        console.log(music.slice(1, 3)); // index 1, 2 
        // ["jazz", "rock"]
        console.log(music.slice(1)); // index 1 부터 ~
        // ["jazz", "rock", "classic", "rnb", "funk", "pop"]

        
        // 12. .reverse()
        // 반환 값
        // - 정렬한 배열. 원본 배열이 변경됨. 복사본이 아님.
        const array1 = ["one", "two", "three"];
        const reversed = array1.reverse();
        console.log(reversed); // ["three", "two", "one"]
        console.log(array1); // ["three", "two", "one"] 원본 배열도 변경된다.

        // 13. sort()  
        // 기본 정렬 순서 : 문자열의 유니코드 코드 포인트를 따른다.
        // 구문 
        // - arr.sort( [compareFucntion] )
        // 매개변수 : compareFunction 
        // - 정렬 순서를 정의하는 함수이다. 생략하면 배열은 각 요소의 문자열 변환에 따라 각 문자의 뉴이 코드 포인트 값에 따라 정렬된다. 
        // 반환 값 
        // - 정렬한 배열. 원 배열이 정렬된다. 복사본이 아님.

        const months = ["March", "Jan", "Feb", "Dec"];
        months.sort();
        console.log(months); // ["Dec", "Feb", "Jan", "March"]

        var numbers = [4, 20, 52, 512, 1, 32];
        console.log(numbers.sort()); // [1, 20, 32, 4, 512, 52]
        // 매개변수가 되는 compareFunction이 제공되지 않으면 요소를 문자열로 변환하고 유니코드 순으로 배열됨. 원하는 결과값이 나오지 않을 수 있음.
        
        // sort 메소드는 클로저와 함께 사용할 수 있다.
        numbers.sort(function(a, b) {
            return a - b; // 오름차순으로 정렬된다.
        });
        console.log(numbers);
        // [1, 4, 20, 32, 52, 512]

        // [참고]
        // 매개변수로 오는 비교 함수의 형식은 아래와 같다.
        // function compare(a, b) {
        //     if( a가 b보다 작을 경우 ) {
        //         return -1; // a가 먼저 온다.
        //     }
        //     if( a가 b보다 클 경우 ) {
        //         return 1; // b가 먼저 온다.
        //     }
        //     // a must be equal to b
        //     return 0; // a와 b를 서로에 대해 변경하지 않는다.
        // }

        // map을 사용하여 정리하기도 한다. 
        // compareFunction이 여러번 호출되는 경우 높은 오버헤드가 발생할 수 있기 때문.

        // 14. concat()  
        // 기존의 원본 배열을 변경되지 않는다.
        // 매개변수
        // - 배열 또는 값, 인자를 생략할 경우 기존배열의 얕은 복사본을 반환.
        // 반환값 
        // - 추가된 새로운 배열을 반환한다.
        
        const array2 = ["가", "나", "다"];
        const array3 = ["라", "마", "바"];
        const array4 = ["사", "아", "자"];
        const concatArray = array2.concat(array3, array4);
        
        console.log(array2); // 원본은 손상되지 않는다.
        console.log(concatArray);
        // ["가", "나", "다", "라", "마", "바"]

        // 15. toString()
        // 반환값
        // - 배열을 문자열로 반환한다.
        var array5 = ["가", "나", "다", "라"];
        var myVar = array5.toString();
        console.log(myVar); // 가, 나, 다, 라



                // // 객체 shallow copy
                // var originArray = [
                //     {name : 'a'},
                //     {name : 'b'},
                //     {name : 'c'}
                // ];
                
                // var shallow = Array.prototype.slice.call(originArray); 
                // // shallow라는 껍데기만 새로 만든 것. 
                // // 내부 객체들은 참조관계로 이어져 있다. 
                
                // shallow[0].name = '변경'; // originArray에도 변경 됨.
                // // 내부 객체에 직접 접근하여 변경해야 한다.
                
                // shallow[1] = '변경안됨'; // originArray에서 변경 안 됨.
                // // 바깥 껍데기를 변경하려는 것과 같다.
                
                // console.log(shallow); // 위 코드가 모두 적용됨.
                // console.log(originArray); // [{name: "변경"}, {name: "b"}, {name: "c"}]


                // // 객체 deep copy
                // function copyObj(obj) {
                //     var copy = {}; // 카피할 빈객체를 만든다.
                //     if( Array.isArray(obj)) { // obj가 배열일 때
                //         copy = obj.slice().map( (v) => {
                //             return copyObj(v);
                //         });
                //     } else if ( typeof obj === 'object' && obj !== null ){ // obj가 객체(object)이고, null이 아닐 때
                //         for( var attr in obj ) {
                //             if ( obj.hasOwnProperty(attr) ) {
                //                 copy[attr] = copyObj(obj[attr]);
                //             }
                //         }
                //     } else { // 그 외
                //         copy = obj;
                //     }
                //     return copy;
                // }
                // var obj = { a:1, b:2, c:[{d:null, e:'f'}]};
                // var obj2 = copyObj(obj);
                // obj2.a = 3;
                // obj2.c[0].d = true;
                // console.log(obj.a);
                // console.log(obj.c[0].d);

    </script>
</body>
</html>