<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
<p>해도해도 까먹는...어려븐 자바스크립트... ㅠㅡㅠ...따흑~!</p>
<p>오늘 공부한 내용들</p>
<ul>
    <li>상황에 따라 달라지는 [this]</li>
    <li>[실행 컨텍스트] 조금</li>
    <li>
        <p>[호이스팅]과 함께 알아두면 좋은</p>
        <ul>
            <li>함수 선언문과 함수 표현식</li>
        </ul>

    </li>
</ul>
<p>어째 순서가 거꾸로인듯..?</p>
<div>
    <p>체크체크</p>
    <ul>
        <li>
            [*체크할 점 1] <br>
            저 arguments에 전달된 인자를 담은 것. <br>
            -> arguments도 변수 선언/할당과 같다. <br>
        </li>
        <li>
            [*체크할 점 2] <br>
            environmetRecord에 뭐가 저장되냐면~ <br>
            현재 실행될 컨텍스트의 대상 코드 내에 '어떤 식별자'들이 있는지에만 관심이 있다~~ <br>
            할당은 노상관이여 <br>
            따라서 변수를 호이스팅할때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다!! <br>
            (구래서 실행컨텍스트 하는데에 호이스팅 개념이..!) <br>
        </li>
    </ul>
</div>
<script>
    /*
    This
    - 함수와 객체(메서드)의 구분이 느슨한 JS에서 this는 실질적으로 이 둘을 구분하는 거의 유일한 기능.

    1. 상황에 따라 달라지는 this
        this의 결정 시점 : 함수를 호출할 때. (=실행 컨텍스트가 생성될 때)
        실행 컨텍스트는 함수를 호출할 때 생성된다.
        바꿔 말하면 함수를 호출할 때 this가 결정된다고 말 할 수 있다.
    1-1. 전역공간에서의 this
        전역 공간에서 this는 전역 객체를 가리킴 (전역 컨텍스트를 생성하는 주체가 전역 객체이기 때문)
        
        JS 런타임 환경에 따라 전역객체는 다른 이름과 정보를 가진다.
        - 환경 : 브라우저, 전역객체 : window
        - 환경 : Node.js, 전역객체 : global

        [*] 전역객체에 전역변수를 선언하면 이를 전역객체의 프로퍼티로도 할당한다.
            변수이면서도 객체의 프로퍼티이기도 하다.
*/
var a = 1; // 전역변수 a에 1을 할당하였다.
        console.log(a); 
        console.log(window.a);
        console.log(this.a);
        // 모두 1이 출력된다. 
        // 여기서 알 수 있는 것은 
        // "자바스크립트의 모든 변수는 실은 특정 객체의 프로퍼티로 동작한다는 것"이다.
        // [*] 여기서 특정 객체라 함은 실행 컨텍스트의 렉시컬 환경(L.E)
        //      실행 컨텍스트 : 실행할 코드에 제공할 환경 정보 모음.
        
                /* 실행 컨텍스트와 콜 스택 */
                // 콜 스택에 실행 컨텍스트가 어떤 순서로 쌓이고, 어떤 순서로 코드가 실행되는지 보자.

                // ---(1) 코드를 실행하는 순간 전역 컨텍스트가 콜 스택에 담긴다.
                // 전역 컨텍스트
                // : 최상단의 공간은 코드 내부에서도 별도의 실행 명령 없이 브라우저에서 자동으로 실행한다.
                // : 자바스크립트 파일이 열리는 순간 전역 컨텍스트가 활성화된다.
                var b = 2;
                function outer() {
                    // var b = 4;
                    // b = 5; 
                    console.log('위' + b);
                    function inner() {
                        console.log('inner ' + b); // 호이스팅에 의해서 선언부만(84라인의 var b 이다.) 올라가기에 할당된 것이 없으므로 undefined
                        var b = 3; 
                        // b = 3; // [!] var를 쓰지않고 b = 3; 이렇게 한건 '재할당'인데 이럴 경우에는 처음 선언된 전역변수 b를 가리킨다.
                    }
                    inner(); // ---(2)
                    console.log('outer ' + b); // 2
                }
                outer();
                console.log('global ' + b); // 전역 변수 b 2
                // 실행 컨텍스트 : 1전역컨텍스트 - 2.outer - 3.inner 
                // 스택구조로 쌓인다는 점.

                /* VE 와 LE */
                /*
                    VE : 담기는 내용은 LE와 동일, but 최초 실행 시의 스냅샷을 유지.
                    LE : 컨텍스트를 구성하는 환경 정보들의 사전. 모음집.
                    
                    저 환경들 안에는 무엇들이 들어있나요?
                        - environmentRecord (VE에는 +snapShot)
                        : 현재 컨텍스트와 관련된 코드의 식별자 정보들 (매개변수 식별자, 선언한 함수, var로 선언된 변수의 식별자 등)
                        [*] 여기서 호이스팅이라는 개념이 나옴.
                        - outerEnvironmentRefence (VE에는 +snapShot)

                    [*] 호이스팅 규칙
                    위에서 environmentRecord에는 매개변수의 이름, 함수 선언, 변수명 등이 담긴다고 했다. 예를 하나 들어보자.
                */
                    // 호이스팅 예제1. 
                    // 예제 코드.
                    function c1(x) {
                        console.log(x); // 1
                        var x; // 이 선언부는 무시가된다. 이유는 호이스팅을 이해하면 ㅇㅋ.
                        console.log(x); // 내답 undefined, 답 1
                        var x = 2;
                        console.log(x); // 2
                    }
                    c1(1);
                    /*
                        저자가 우려했던 착각을 내가 그대로 하게 됨.
                        왜 undefined이 아닌 1이 출력될까? -> 호이스팅 떄문.

                        [*체크할 점 1] 
                        저 arguments에 전달된 인자를 담은 것.
                        -> arguments도 변수 선언/할당과 같다. 

                        [*체크할 점 2]
                        environmetRecord에 뭐가 저장되냐면~
                        현재 실행될 컨텍스트의 대상 코드 내에 '어떤 식별자'들이 있는지에만 관심이 있다~~
                        할당은 노상관이여
                        따라서 변수를 호이스팅할때 변수명만 끌어올리고 할당 과정은 원래 자리에 그대로 남겨둔다!!
                    */
                    // 호이스팅 예제1. 
                    // 예제 코드 -> 호이스팅 코드로
                    // 결론
                    function c1H(x) {
                        var x; // 수집대상1 매개변수 선언
                        var x; // 수집대상2 변수 선언
                        var x; // 수집대상3 변수 선언
                        /*---------호이스팅---------*/
                        x = 1; // 수집대상1의 할당 부분
                        console.log(x); // 1
                        console.log(x); // 1
                        x = 2; // 수집대상3의 할당 부분
                        console.log(x); // 2
                    }
                    c1H(1);

                    // 위와 비슷한 호이스팅 예제2.
                    // 예제 코드
                    function c2() {
                        console.log(x); // undefined
                        var x = 'xxx'; // (선언과) 할당
                        console.log(x); // 'xxx'
                        function d() {};    
                        console.log(d); // f d(){}
                    }
                    c2();

                    // 호이스팅 예제2.
                    // 예제 코드 -> 호이스팅
                    function c2() {
                        var x; // 변수는 선언부만 호이스팅
                        var d = function d() {}; // 함수는 함수명으로 선언한 변수에 함수를 할당한 것처럼 여겨진다.
                        /*---------호이스팅---------*/
                        
                        console.log(x); // undefined
                        x = 'xxx';
                        console.log(x); // 'xxx'
                        
                        console.log(d) // f d(){}
                    }
                    c2();
                    /*
                        호이스팅 예제2번을 풀어서 설명하자면,
                        함수가 실행이 되면.. 
                        1) 순간 함수의 실행컨텍스트가 만들어진다.
                        이떄 변수명과 함수 선언의 정보가 호이스팅된다. (- 끄집어 올려서 수집하는 과정이라고 생각하면 된다.)
                        변수는 선언부와 할당부를 난누어 '선언부'만 채택하고,
                        함수는 '함수 전체'를 채택한다. 
                    
                    */

                    function test() {
                        console.log(b); // f b() {}
                        var b = 'xxx';
                        console.log(b); // xxx
                        function b() {};
                        console.log(b); // xxx
                    }
                    test();
                    // 위 test함수 호이스팅 결과
                    function test() {
                        var b;
                        var b = function b() {};

                         /*---------호이스팅---------*/
                        console.log(b); // f b() {}
                        b = 'xxx'; // 재할당처럼 된다.
                        console.log(b); // xxx
                      
                        console.log(b); // xxx
                    }
                    test();

                    
                    // 호이스팅 예제3.
                    // 예제 코드
                    function c3(x){
                        console.log(x); // a(){}
/**/                    function c3(){} // 요 함수가....
                        var x=7;
                        console.log(x); // 7
                    }
                    c3(10);
                    
                    // 호이스팅 예제3.
                    // 예제 코드 -> 호이스팅 코드로
                    // 과정
                    function c3H(x){
                        console.log(x); // a(){}
/**/                    var x = function x(){} // 원래는 이거와 같다는 것. <- 이건 어제 공부한 것. 
                        var x=7;
                        console.log(x); // 7
                    }
                    c3H(10);

                    // 호이스팅 예제3.
                    // 예제 코드 -> 호이스팅 코드로
                    // 결론
                    function c3H(x){
                        var x;
                        var x = function x(){};
                        /*---------호이스팅---------*/

                        console.log(x); // a(){}
                        x = 7;
                        console.log(x); // 7
                    }
                    c3H(10);

                    /* 함수 선언문과 표현식 */
                    // 함수 선언문 : function 정의부만 존재. 별도의 할당 명령이 엄슴. 대신 함수명이 꼭 정의되어 있어야 한다. 
                    function 함수명꼭정의() {};
                    함수명꼭정의(); // 함수 선언문. 함수명 '함수명꼭정의'가 곧 변수명


                    // 함수 표현식 : 정의한 function을 별도의 변수에 할당하는 것.
                        // 익명 함수 표현식
                    var 함수표현식은이렇게변수를선언해준다 = function() {};
                    함수표현식은이렇게변수를선언해준다(); // 변수명으로 실행시킨다. 변수명이 곧 함수명

                        // 기명 함수 표현식
                    var 변수도있고 = function 함수명도따로있을때() {};
                    변수도있고(); // 변수명으로는 가능. but
//[함수는변수명으로호출]  함수명도따로있을때(); // 함수명으로 함수 호출 불가능. 
                    
                    // 결론 > 함수는 변수명으로 실행시킨다는 점.
                    // 결론2 > 기명 함수 표현식의 경우 외부에서는 함수명으로 함수를 호출할 수 없다는 점. 

                    /* 함수 선언문과 함수 표현식의 차이 */
                    console.log(선언문(1,2)); // 3 
                    // console.log(표현식(3,4)); // 표현식 is not a function

                    function 선언문(a, b) {
                        return a + b;
                    };

                    var 표현식 = function (a, b) {
                        return a * b;
                    };
                    // 실행 컨텍스트의 LE는 두가지 정보를 수집한다. 여기서는 그 중 environmentRecord의 정보 수집 과정에서 발생하는 호이스팅을 살펴보는 중.
                    
                    // 왜 이런 대참사가 일어나는지 호이스팅의 최종 상태를 보자면
                    var 선언문 = function 선언문(a, b) {
                        return a + b;
                    }; // > 선언문은 함수 전차가 호이스팅 되며,
                    var 표현식; // > 표현식은 변수명(선언부)만 호이스팅되기 때문에 콘솔로 찍어보면 'not a function'이라는 결과가 나올 수밖에..
                    /*---------호이스팅---------*/
                    console.log(선언문(1,2));
                    // console.log(표현식(3,4));

                    표현식 = function (a, b) { // > 변수의 할당부는 원래 자리에 남겨둔다.
                        return a * b
                    };
                    
                    /*
                        내부 코드 
                        275l : 메모리 공간을 확보하고 확보된 공간의 주솟값을 변수 '선언문'에 연결.
                        276l : 또 다른 메모리 공간을 확보. 그 공간의 주솟값을 변수 '표현식'에 연결.
                        다시 275l : '선언문'함수를 또 다른 메모리 공간에 저장하고, 그 주솟값을 변수 '선언문'의 공간에 할당한다.
                                    이로써 변수 '선언문'은 함수 '선언문'을 바라보는 형태가 된다.
                        278l : 정상 실행으로 3 출력
                        279l : 현재 '표현식'에는 값이 할당돼 있지 않다. 비어있는 대상을 함수로 여겨서 실행하려고 하니 자기는 함수가 아니라고 경고문을 띄워준다.
                    */
                    

                    /* 함수 선언문의 위험성 */
                    console.log("함수 선언문의 위험성");
                    
                    console.log(sum(3, 4));
                    function sum(x, y) {
                        return x + y;
                    };
                    var a = sum(1,2);
                    function sum(x, y) {
                        return `x + y = ${x + y}`;
                    };
                    var c = sum(1,2);
                    console.log(c)
                    
                    console.log(`
                        위와 같이 선언문으로 정의해놓고, 또 밑에서 같은 변수명으로 함수를 정의할 때 문제가 생긴다.
                        심지어 오류를 넘겨주지도 않기 때문에 디버깅할 때 힘들다.
                        그래서 선언문보다는 표현식으로 쓰는 것이 좀 더 안전하다.
                    `);

                    /* 상대적으로 함수 표현식이 안전하다 */
                    console.log("함수 표현식이 안전");

                    // console.log(sum1(3,4)); // error > sum1 is not a function
                    var sum1 = function(x, y) {
                        return x + y;
                    };
                    var a = sum1(1, 2);
                    console.log(a)

                    var sum1 = function(x, y) {
                        return `x + y = ${x + y}`;
                    };
                    var c = sum1(1, 2);
                    console.log(c);



// 궁금한 점..
// 파일을 따로 만들어서 js 코드를 짜면 전역변수는 어떻게 돌아가게 되는거지?
// 따로 전역객체가 생기는 것인가? 그렇지 않다면 즉시실행함수같은걸로 함수가 실행되고 그 다음에 바로 없애는 형태의 함수로 짜나?


                    /* 스코프와 스코프 체인, outerEnvironmentReference */
                    /*
                        스코프 : 식별자에 대한 유효범위. 함수에 의해서만 생긴다.
                        스코프 체인 : 식별자의 유효범위를 안에서부터 바깥으로 검색해나가는 것.
                            (함수 A의 외부에서 선언한 변수는 A의 외부 뿐만 아니라 A의 내부에서도 접근이 가능
                            그러나 A의 내부에 선언한 변수는 A내부에서만 접근할 수 있다.)
                        이러한 스코프 체인이 가능하게 만드는 것이 바로
                        'outerEnvironmetReference'
                    
                    
                    
                    */

                    // // 함수는 호출될 떄, 매개변수로 전달되는 인자값 이외에, 'arguments 객체(유사배열임)'와 'this'를 암묵적으로 전달 받는다.
                    // function square(number) { // 요놈이 아규먼트, 받는 통로이자 변수.
                    //     console.log(arguments);
                    //     // > Arguments [2, callee: ƒ, Symbol(Symbol.iterator): ƒ]
                    //     console.log(this);
                    //     // > Window {window: Window, self: Window, document: document, name: "", location: Location, …}

                    //     return number * number;
                    // }
                    // square(2); // 요놈이 인자, 전달하는 실제 값
        
                
</script>
<!-- <script>

    console.log('멍청이인 나는 다시 한 번 호이스팅을 공부한다....ㅠ');

    var first = 100; // 전역변수로 선언했다.

    function outer() {
        function inner() {
            console.log(first); // 이 first는 스코프 체인에 의해서 '가장 가까운' 전역변수 first를 참조한다.
            1. var fisrt = 300; // 상황1. 마냥
        }
        inner(); // 100
    }
    outer();
    console.log('전역에서 ' + first); // 전역에서 100

    ////////////////

    var second = 200;

    function outer() {
        function inner() {
            console.log(second); // 스코프란, 식별자의 유효범위이다. es5까지의 JS는 전역공간을 제외하고 '오직 함수에 의해서만' 스코프가 생성된다.
            // 가장 가까운 second는 요 바로 밑에 선언/할당 되어있는 second=300이다. 
            // 그럼 300이 출력될까? ㄴㄴ 호이스팅에 의해서 undefined가 출력된다.
            var second = 300; // 300을 할당했으나 이 함수 안에서 사용하는거 아닌 이상 의미가 없다.
        }
        inner(); // 위와 같은 이유로 undefined 출력
        console.log(second); // 스코프 체인에 의해서 가장 가까운 바깥 영역의 second를 찾는다. 200 출력
    }
    outer(); 
    console.log(second); // 200

    /////////////// 
    //위 코드가 호이스팅 됐을 때.

    var second; // 선언부
    // var outer = function outer() {...};
    /*---------호이스팅----------*/
    second = 200;

    function outer() {
        function inner() {
            var second;
             /*---------호이스팅----------*/
            console.log(second); // undefined
            second = 300;
        }
        inner(); 
        console.log(second); // 200
    }
    outer(); 
    console.log(second); // 200


</script> -->
<script>
    console.log('스코프 체인');

    var a = 1;
    var outer = function() {
        var inner = function() {
            console.log(a); // 1
            a = 3; 
        };
        inner(); 
        console.log(a); // 3
    };
    outer();
    console.log(a); // 3

                                      
</script>
</body>
</html>