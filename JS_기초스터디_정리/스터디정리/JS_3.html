<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>
<body>
<p>함수(function)와 배열</p>
<script src="http://code.jquery.com/jquery-latest.js"></script>
<script>
    // 함수 정의, 호출, 인자, 종료 및 리턴값

    // 선언문 - 함수의 호이스팅이 일어난다.
        // 1) sum() - 호출 가능
        // function sum() {
        //     // ..
        // }
        // 2) sum() - 호출 가능

    // 함수 호이스팅을 추천하지 않는 이유는 > 여럿이서 동시 작업을 할 경우, 브라우저가 함수를 읽어들이는 순서가 꼬일 수 있다.

    /*--------------------------------------------------------------------------------------------------------*/

    // 익명함수 - 호이스팅 되지 않는다. 
        // var sum = function() {
        //     // ..
        // }

    // * 익명함수는 반드시 함수를 호출하는 코드보다 먼저 작성되어야 한다 (함수 호이스팅 X)
    // [실행 컨텍스트 개념 공부필수]
    // 전역 컨텍스트가 생기고 그 페이지 안에 함수가 하나하나 실행될 때 마다 함수 컨텍스트가 생긴다. 

    /*--------------------------------------------------------------------------------------------------------*/
    /*--------------------------------------------------------------------------------------------------------*/

    // 함수는 정의를 하고, 반드시 호출을 해줘야 합니다.

    // 함수 인자 (=parameter)

    // 함수 종료 및 리턴값
    // return

    /*--------------------------------------------------------------------------------------------------------*/
    // 즉시 실행 함수 
        // (function(name) {
        //     console.log(name);
        // })('foo');   
    // 페이지가 실행되면서 자바스크립트가 읽어지는 순간 실행되는 함수이다.
    // 함수가 저장되어있지 않는 즉시 실행되는 함수라서 두번 (다시) 실행되지 않는다. 
    // 한 번 실행되고 바로 종료. 

    // 특징: 다시 호출 안 된다. 최조 한 번의 실행을 필요로 하는 초기화 코드에서만 사용.
        // 초기화? > js도 common.js와 같이 흔히 많이 쓴다.

    // 왜 즉시실행함수인가? 
        // 변수를 보호하는 능력이 있다. (은닉화) 굳이하고시다면 윈도우에 저장. 
        // jquery나 프레임워크에서 사용. 중복이되거나 하면 오류가 떠서 멈추기 떄문
        // 전역 유효 범위를 갖는다.
        // 즉, 함수 외부의 코드에서 내부의 변수 액세스가 불가능
        // '전역 네임스페이스'를 더럽히지 않으므로 충돌 방지 가능.
    
    // 함수 주요 메서드
    // apply, call로 this를 인자로 들어온 object로 변경하게 함.

    // [Rcmd!] 시간이 있다면 '일급 객체란?', '실행 컨텍스트?', '클로저?' 를 공부해 올 것.

    /*--------------------------------------------------------------------------------------------------------*/
    // 타이머
    // 윈도우 객체 매서드이다. 지정된 시간마다 함수를 호출할 수 있음.
    // setTimeout('실행할 함수', 대기시간) - 대기 시간 후 한 번만 실행
    // clearTimeout - setTimeout을 해제
        // var gallery = function() {
        //     console.log('다음 사진');
        // };

        // var clearId = setTimeout(gallery, 1000);

    // setTimeout을 해제
        // clearTimeout(clearId);

    // 언제 사용해요? 동시다발적으로 스크립트를 사용하게 되면 특정 구문이 실행되지 않을 때 가 있는데, 의도적으로 시간을 주어서 조절할 수 있다. 
    // 약간의 텀을 줘서 오류를 해결한다.


    // - setInterval
    // - clearInterval
        // var count = 1;
        // var gallery = function() {
        //     console.log('다음 사진');
        //     // count += 1; 
        //     if(count == 5) {
        //         clearInterval(clearId);
        //     }
        //     count += 1; 
        //     // 변수를 증감시킬 때에는 증감되는 구문이 어디에 들어가느냐에 따라서도 달라지니 잘 계산을 해야한다.
        // };
    // var clearId = setInterval(gallery, 100);
    // 마우스가 올라갈 때 클리어를 해주고, 나갈 때 다시 실행해줄 수 있다. 

    /*--------------------------------------------------------------------------------------------------------*/
    // 배열(Array) - 객체
    // 배열 선언 방법
    // 1) [] 빈 배열로 
    // 2) new Arrya();

    // var array = new Array(); // 프로토타입 속성을 가지고 있다면 new를 사용하여 할 수 있다. 
    // // new Function() 등등..
    // var array = []; // 하지만 회사에서는 이렇게 쓴다.

    // // 여러개의 데이터를 인덱스로 관리할 수 있다.
    // array[0] = '햄버거'; - 인덱스
    // array.push();

    // // []를 선언하지 않아도, 여러 개의 값이 들어있으면 무조건 배열처럼 사용할 수 있다. (유사배열)
        // var obj = {
        //     name: 'heemyun',
        //     //키와 키값
        //     age: 24
        // };

        // obj.name // <- 접근 가능
        // obj[0] // <- 접근 가능


        // var arrayNames = [];
        // console.log(arrayNames.length); // 0

        // arrayNames = [10, 20];
        // console.log(arrayNames.length); // 2

        // arrayNames[100] = 'A';
        // console.log(arrayNames.length); // 101

        // arrayNames = []; // 다시 초기화
        // console.log(arrayNames.length);

    /*--------------------------------------------------------------------------------------------------------*/
    // 객체(Object)
    // 배열과 비슷하나 구체적이고 상세하다. 
    // 데이터와 연산 작업을 담고 있는 덩어리

    // var objNames = {}; // 객체 생성
    // 객체는 체이닝으로 추가한다.

    ///////////////////////////////////////////////////
        // var objNames = {
        //     a: 10,
        //     name: '홍길동',
        //     fn: function() {
        //         alert(this.name); // objNames에서 실행했으니 this는 objNames를 가리킨다. 
        //     }
        // }
        // objNames.fn();

        // // for in 반복문 (객체에서는 이걸로 적용한다.)
        // for(var key in objNames) {
        //     console.log(key + ' : ' + objNames[key]);
        //     // 키 : 키값 
        // }

    ///////////////////////////////////////////////////
    // 객체 값 삭제하는 방법
        // 복사를 하는데 그 지울 값만 뺴고 가져오는 방법을 사용
        // 굳이 delete를 사용하지는 않는다. (원본 손상이 되기 떄문)
        
        // delete objNames.name;
        // console.log(objNames.name); // undefined

    // 객체 주요 메서드 hasOwnProperty

    /*--------------------------------------------------------------------------------------------------------*/
    // Math 
    // https://www.w3schools.com/js/js_math.asp 

    // Date
    // var timedate = new Date();
    // console.log(timedate.getTime()); // 1616547128167
    // console.log(timedate); // Wed Mar 24 2021 09:52:08 GMT+0900 (대한민국 표준시)

    /*--------------------------------------------------------------------------------------------------------*/
    // BOM (browser object model)
    // 과제 링크 확인


    // var obj = function() {
    //     console.log(this);
    // }
    // new obj();


    // 코카
    // 1. 셀렉터 정리
    // 2. 세 버튼 중 선택이 되어있는지 아닌지, 그리고 어디가 선택되어 있는지 확인하는 구문
    (function () {
        'use stricr';

        var beargame = {
            init: function() {
                console.log('init');
                this.setElements();
                this.initOpts(); 
                this.bindEvents();
            },
            setElements: function() {
                this.appbtn = $('.btn_app');
                this.boxList = $('.bxlst');
                this.boxItem = this.boxList.children();
                this.boxInput = this.boxItem.find('input');
                this.gameArea = $('.game_area');
                this.gameLane = this.gameArea.children();
            },
            initOpts: function() {
                this.changeInput = false;
                this.compeleteGame = false; // 게임이 완성되었는지 아닌지를 체크한다. 
            },
            bindEvents: function() {
                this.appbtn.on('click', this.onclickFunc.bind(this));
                
                // this.boxInput.on('change', this.onChangeFunc.bind(this)); [!]얘 말고 이 바로 위 부모에게 이벤트를 줘보자.
                this.boxItem.on('change', 'input',  this.onChangeFunc.bind(this)); 
                // input이라고 타겟을 지정하고 넣었다.  input a button 이렇게 ㅅ띄어쓰기로 넣을 수도 있다. 
                // currentT 선택한 애
                // deligate 이벤트 부여된 애 
            },
            onclickFunc: function(e) {  // 선택하기 
                e.preventDefault();
                // a에는 #이 있기때문에 상단으로 점프한다 이걸 방지하기 위해서 a의 본연의 기능을 막는다. e.preventDefault
                if ( !this.changeInput ) {
                    alert('곰을 선택해주세여~~');
                } else if (this.compeleteGame) {
                    alert('이미 선택이 완료되었습니다.');
                    this.randomFunc();
                } else {
                    // 곰을 선택을 했다면 else 구문이 실행된다.
                    this.animateFunc();
                }
            },
            onChangeFunc: function(e) {
                console.log('체인지 되었나요?');
                // 이 상태값을 위에다가 추가해보자. initOpts
 
                var target = $(e.delegateTarget); // 얘는 지역변수라 외부에서 쓸 수 없다
                this.targetIndex = target.index(); // 다른데서 쓸 애는 이렇게 this로 선언해주자.

                this.changeInput = true; // 체인지가 되었다면 true로 값을 바꿔준다.
                // 여기서 내가 선태한게 뭔지 알아보자.
            
            },
            animateFunc: function() {
                var targetLane = this.gameLane.eq(this.targetIndex),
                    moveTarget = targetLane.find('.gom'); // gom이 병뚜껑
                
                targetLane.addClass('winlane');
                moveTarget.stop().animate( { // 애니메이트같은 경우는 stop을 넣어줘야 좋다.
                    top: '115px'
                }, 500);
                this.compeleteGame = true;
            },
            randomFunc: function() {
                // 변수에 선택 안된거 집어넣고,
                // 거기서 random 돌려서
                // 함수 호출하면 되지 않을까.
            },
        };
        beargame.init();
    })();

    // (선택한 인덱스 제외) 선택을 하지 않은 인덱스 두개가 랜덤으로 내려 올 수 있게 만들어주세요.
    // 배열 사용
    // math.random 사용

</script>
</body>
</html> 