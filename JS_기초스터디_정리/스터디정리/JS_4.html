<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>
<body>
<script>
    // 조건문
    // 1. if
    // 2. while 데이터가 정적으로 변하지 않을 떄, 조건이 많을 때, 단순한 반복문 

    // 반복문

    // 함수
    // 1. 선언, 2. 표현(익명), 3. 즉시실행함수(->스코프관리), 4. arrow func
    
    // apply, call, this 저장 - 이거 다시 정리하기

    // settimeout으로 시차를 통해 동시에 다량의 코드가 실행되는 것을 막을 수 있따. 

    // [배열] {객체}

    // hasOwnProperty 

    // Math - 애니메이션.. webgl

    // 

    // 예제
    var myObject = {
        name: 'foo',
        sayName: function() {
            console.log(this.name);
        }
    };
    var otherObject = {
        name: 'bar'
    };

    otherObject.sayName = myObject.sayName;

   
    myObject.sayName(); // foo
    otherObject.sayName(); // bar 
    // 참조 방식에 따라 this가 바뀐다

    var test = 'this is test'; // winodw에 test가 저장되어 있다. 
    console.log(window.test);

    var sayFoo = function() {
        console.log(this.test); 
        console.log(window.test);
    }
    sayFoo(); // 일반함수이므로 this는 window가 된다. 


  
    // - 함수의 형태는 함수
    // - 생성자 함수의 형태는 객체, 상황에 따라서 
    // 재활용가능하고 객체 수정이 용이하다. 


    // 사용하는 이유 : 컴포넌트 단위 레벨, 객체 수정용이, 여러번 호출하기 용이 
    // 생성자 함수로 호출하는 방법
    // 함수를 생성을하면 프로토타입이 생성이 되는데 이것을 우리가 수정을 할 수 있따. 
    (function(win, $, doc, isUndefined) {  // 맨 아래에서 이렇게 넘겨주면 위에서 이렇게 받는다.
        // console.log(arguments).. 찍어보면 언디파인드 나옴 얘를 활용하려면,isUndefined 로 활용한다.
        // 1. 참조할 함수가 있다.
        var Component = function(container, args) {
            console.log(container)
            console.log(args) // 들어오는 top값은 130인데
            var defParams = {
                obj : container,
                top : null, // 일단은 null로 초기화를 해둔 상태이고,
                box : '.box',
                swiperObj : '.swiper-slide',
                slideOpts : {
                    arrow : true,
                    dots : flase
                }
            }
            this.opts = $.extend() // 객체와 객체를 머지해준다. 약간 머지할 수 있는 뎁스가 깊지 않다..
            this.opts = Util.def(defParams, args) // hivelab common js (미리 짜둔거ㅇㅇ) 깊은 복사임
            // defParams과 args를 복제한다라는 의미임
            // 더 구체적으로 한다면..
            this.opts = Util.def(defParams, {args || {}}); 
            // args가 있다면 가져오고 없다면 빈 객체로 가져와라 
            this.init(); 
        };

        // 2. 위에 참조한 함수로 객체를 만드는 것.
        Component.prototype = {
            // d이 안에서 우리가 정의했던 init...가튼 함수르른다. 
            // opts : {
                // 1.의 함수가 2.를 바라보고 있고, 1에서 정의한 opts가 지금 주석 단거처럼 
                // 이렇게 들어와있다고 생각할 수 있다.
            // }
            init: function() {
                console.log(this.opts);
                // new Swiper('.swiper-slide', {
                //     arrow : true,
                //     dots : false
                // }) 이게 아니라
                new swiper(this.opts.wiperObj, this.opts.slideOpts);
            }

            // 예를 들면
            setElements : function() {
                this.어쩌구.on('click', this.init.bind(this)) <= 요기서 왜 this를 바인드 해주나여..?? 디스가 둘이 다른건가용~~
                
            }
        },

        // 페이지가 로드되면..이라는 뜻임. : $(fucntion() {})
        $(function () {
            new component('.box', {
                // 옵션값을 넘겨주기 위해 {} 객체로 던져준다. 예를 들어 코카에서 px값이 바뀐다면
                top : '130px',
                bttom : { // 이렇게 또 객체안에 객체가 들어가는 걸 뎁스라고 함.

                }
                
            }); // 박스라는 인자를 가지고왔다 쟤는 저 위에 던지자 -> container가 받게됨.
            // 이렇게 실행시켜줌. 
            // !! 여기서 생성해주면 함수가이날 객체형태로 호출이 되고, 그 객체에 자동을 this가 바인딩된다.
            new component('.wrapper', {
                top : '200px',
            }); 
        })
    // })();
    })(window, window.jQuery, window.document); // 이렇게 날려줄 수도 있는데, 받아오는 값은 (win, $, doc) 맨 위 함수에 넣어줌.



    // 과제 조건
    // 1. 새로고침 할 때 마다 '랜덤한 캐릭터'가 노출된다. 
    // 2. [다른 아바타 보기 버튼]을 누르면 '이 전에 보여지지 않았던' 랜덤한 캐릭터가 보여진다.  (같은 캐릭터 중복되면 안 됨.)
    // 3. 모든 캐릭터가 다 노출이 됐으면, 다시 시작하는거.. 
    // 3-1. +) 다람쥐가 마지막에 노출이 되었다 다시 시작됐을 때 또 다람쥐가 나오면 안됨. 
    //          마지막과 첫번째가 중복되면 안 됨!
    // 4. li는 무조건 Jquery의 show, hide로 컨트롤한다. li remove 하지마셈 !! 
    // 5. 배열 사용해라 math.random
    
    // -> 어떤 배열의 형태로 만들것인가?
    // --> 배열 형태 2가지
    // -----> 1. [0, 1, 2, 3, 4, 5, 6, ..] 11개를 푸시해서 랜덤으로 뽑을 것인가. <- 이 방법으로 하세요. 여기서 랜덤으로 뽑는 방법을 사용.
    // -----> 2. [5, 7,2, 3, 1, ,2 ,5, 11,] 애초에 랜덤으로 해서 뽑을 것인가. <- 일단 랜덤으로 배열이 만들어지면, 예상이 가능하기 때문에 맞지 않음.

    // 랜덤으로 5가 뽑혔다? 원본 배열에서 지워줘야겟죠? 
    // '뽑힌 값'과 '인덱스'를 헷갈리지 말 것 ㅋㅋ 뽑힌 값 != 인덱스 라는 거 잊지마~~
    

    // 검수할떄 나머지 li 다 주석해놓고 2개로만 검수해 볼 것.

    1. 배열을 받아온다
    2. 원본 / 깊은복사 새로만들고
    3. 깊은 복사한 애에서 랜덤으로 뽑기
    4. 빈 배열이 될 때 => 사이클 돌았다. 처음으로 (원본에서 다시 깊은복사를 ㅎ ㅏㄴ다.)



</script>
</body>
</html>