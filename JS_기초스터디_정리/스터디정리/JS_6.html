<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>JS 6</title>
</head>
<body>
    반응형
<script src="https://code.jquery.com/jquery-3.4.1.js"></script>
<script>
    // 해시체인지
    // - url 주소 뒤에 #~어쩌구가 바뀜 이것을 해쉬라고 함.
    //     주소창에서 바꿔도 탭이 바뀐다 (화면이 바뀐다.)
    // - 히스토리가 저장이 된다. (뒤로/앞으로 가기)
    // - 'hashchange'는 이벤트이다. 주소창에 해시체인지가 일어나면 이벤트가 발생함.
    
    
    // 6과제 
    // 메뉴 호버 시 언더라인과 메뉴 보임
    // 모바일
    // 열기버튼 -> 누르면 right 조절해서 나오게 (animate해도 되고 논블럭해도 되고)
    // 열기 닫기 버튼 구현 / 기능 구현

    // Util 설명
    // def : 객체와 객체 머지  (깊은 복사)
    // jquery는 얕은 복사 
// []   // -> 객체 결과물에 차이가 있다. 기존 객체가 변하냐 안변하냐.. 의 테스트 함 해보기~
        // 깊은 복사는 아예 복사본을 만드는 것, 얕은 복사는 객체의 한 DEPTH 까지만 복사를 한다.

    
    // 윈도우를 던지면 글로벌로 받음. window.common 이라는 이름으로 선언해 놓은것들을 저장한 상태 " 네임스페이스"
    // 윈도우에 글로발로 받아서 커먼으로 저장 -> 
    // RESPONSIVE -> 기기 너비값
    // winSize (util) -> 
(function (win, $) {
    'use strict';
    
    var Util = win.Common.util,
        Mobile = win.Common.RESPONSIVE.MOBILE.WIDTH;

    function gnbComponent(container, args) {
        var defParams = {   
            obj: container,
            menu: '.menu',
            viewType: null,
        }
        this.opts = Util.def(defParams, (args ||{}));
        if (!(this.obj = $(this.opts.obj)).length) return;
        this.init();
    };
    gnbComponent.prototype = {
        init: function() {
            this.resizeFunc(); // 최초 실행시에도 실행시켜줘야한다. 어디서 어떻게 시작될지 모르므로 
            this.bindGlobalEvents(true); // 트루이면
            // this.bindEvents(true); //
        },
        setElements: function() {
            this.menu = this.obj.find(this.opts.menu);
            this.menuItem = this.menu.children();
        },
        // pc와 mo 이벤트는 구분된다. 
        bindPcEvents: function(type) {
            if (type) { // 여기 실행
                this.menuItem.on('mouseenter mouseleave focusin focusout', this.onMouseFunc.bind(this));
                // 같은 이벤트는 옆으로 띄어쓰기로 추가할 수있다. 근데 뭔지 구분을 해야하니까... 
                // 아래와 같이 이프문으로 구분해준다.

                // focusin focusout -> 접근성과 관련이 있다. 마우스가 아닌 키보드로 접근이 가능한 것.
            } else { // False이면 여기
                this.menuItem.off('mouseenter mouseleave');   
                // 제이쿼리 이벤트 보면 마우스오버 아웃으로 나오게 됨.
            }
        },
        bindMoEvents: function(type) {

        },
        onMouseFunc: function(e) {
            if( e.type === 'mouseenter' || e.type === 'focusin') {
                console.log('mouseenter');
            } else if(e.type==='mouseleave' || e.type === 'focusout'){
                console.log('mouseleave');
            }
            console.log('와따가따')
        },
        bindGlobalEvents: function() {
            if (type) { // 여기 실행
                $('win').on('resize', this.resizeFunc.bind(this));
                // 윈도우 이벤트 = 브라우저 이벤트
            } else { // False이면 여기
                $('win').off('resize');
                // 굳이 리사이즈를 나눈 이유는 분리하여야만 기능들이 구현되는 것들이 있기 때문
            }
        },
        resizeFunc: function() {
            this.winWidth = Util.winSize().w; // 가로값을 계속 체크할 것임.
            console.log('resize');
            win.clearTimeout(this.resizeEndFunc);
            this.resizeEndFunc = win.setTimeout(this.onResizeEndFunc.bind(this), 150);
            // 리사이즈가 되는 순간을 계속 찍으니까 셋타임아웅ㅅ을 사용함.
            // 위에서 클리어를 계속 해주므로 계속 지우는 상태, 그러나 멈추면 150뒤에 실행을 해서 찍어주게 된다.
            // -> 성능 최적화에 도움이 조금이나마 된다. 
        },
        onResizeEndFunc: function() {
            console.log('resize end');
        },
        setLayout: function() { 
            if (this.winWidth > MOBILE) { 
                if (this.opts.viewType != 'PC') {
                    this.opts.viewType = 'PC';
                    console.log('pc');
                    this.bindPcEvents(true);
                    // this.bindMoEvents(false);
                }
            } else {
                if (this.opts.viewType != 'MO') {
                    this.opts.viewType = 'MO';
                    console.log('mo');
                    this.bindPcEvents(false);
                    // this.bindMoEvents(true);
                }
            }
        },
    };
    $(function() {
        var gnbComponentCall = new gnbComponent();
    })
})(window, window.jQuery);

<!----------------------------------------------------------------------------------------------------------------------->

// 00.) 해쉬# 는 리로딩 없이 자바스크립트를 불러오기 위한 방법. 
    // 브라우저 히스토리에 url을 남긴다. (그래서 back/forward가 되는 것.)
// 01.) 해쉬 체인지에서 왜 '_'를 쓰는가?
//  https://cis1725.tistory.com/9
//  https://ma.ttias.be/internet-explorer-wont-allow-cookies-subdomains-underscores/
    // 1) 자바스크립트 변수 이름에서 유효한 문자는 $, _이기 때문.
    // 2) IE에서 url에 언더바가 포함되어 있으면 쿠키 저장을 거부하여 쿠키를 저장하지 않는다.
            // 쿠키를 저장하기 위해서 _를 떼는 것 같은데,
            // 그럼 애초에 왜 붙이는거지??????????????????

 
// 02.)📌쿠키의 개념 https://devuna.tistory.com/23
    // 쿠키는 웹 사이트에 접속할 때 생성되는 정보를 담은 임시 파일 (서버 대신 웹 브라우저를 이용하고 있는 컴퓨터에 저장)
    // 쿠키는 서버가 사용자의 웹 브라우저에 저장하는 데이터를 말합니다.
    // 쿠키의 데이터 형태는 Key 와 Value로 구성되고 String 형태로 이루어져 있습니다.


// 0-1. 쿼리스트링
    /**
     *  ? : 쿼리스트링을 시작하는 기호
     *  변수 = 값 한 쌍으로 구성
     *  & : 여러 쌍의 변수와 값을 전달할 경우 &로 구분한다. 
     */

// 1. 네임스페이스
    if (typeof MyModule === 'undefined') {
        var MyModule = {};
    }
    // 네임스페이스 간의 충돌 검사 1
    // 위 코드를 간소화하면 아래와 같이 작성할 수 있다.
    var MyModule = MyModule || {};
    // 네임스페이스 간의 충돌 검사 2
    
// 2. util 구경하기
// 3. 아웃사이드 이벤트 
// 4. 과제는 월요일 10시 제출



</script>
</body>
</html>