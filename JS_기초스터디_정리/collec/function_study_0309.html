<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Document</title>
</head>
<body>
<script>
// [함수]란 어떤 작업을 수행하기 위해 필요한 문들의 집한을 정의한 코드 블록이다.
// 함수는 이름과 매개변수를 갖으며 필요한 때에 호출하여 코드 블록에 담긴 문을 일괄적으로 실행한다.

// [함수의 정의] (함수 선언문)
function square(num) {
    return num* num;
}

// 함수는 호출에 의해 실행되는데 한번만 호출할 수 있는 것이 아니라 여러번 호출할 수 있다.

// [함수의 호출]
square(4); // 16

// 동일한 작업을 반복적으로 수행해야 한다면 (동일 구문을 중복 작성하는 것이 아니라) 미리 정의된 함수를 재사용하는 것이 효율적이다.
// 이러한 특성은 '코드의 재사용' 측면에서 매우 유용하다.

// 함수의 일반적 기능
// - 어떤 작업을 수행하는 문들의 집합을 정의하여 코드의 재사용에 목적이 있다.
// 일반적 기능 외에도
// - 객체 생성, 객체의 행위 정의(메소드), 정보 은닉, 클로저, 모듈화 등의 기능이 있다.

// 자바스크립트는 일급객체이다. 다른 객체와 구분될 수 있는 특징은 '호출'할 수 있다는 것이다.
// 함수도 객체이다. 그러므로 다른값들 처럼 사용할 수 있다. 
// 즉 변수나 객체, 배열 등에 함수를 저장할 수 있고, 다른 함수에 전달되는 인수로도 함수를 사용할 수 있으며, 함수의 반환값으로 함수가 될 수 있다.

/* 1. 함수의 정의 */
// 함수를 정의하는 방식 3가지
// 1) 함수 선언문
// 2) 함수 표현식
// 3) Function 생성자 함수

/* 1.1 함수 선언문 */
// 함수 선언문 (Function declaration) 방식으로 정의한 함수는 function 키워드와 이하 내용으로 구성됨.
// (1) 함수명
// 함수 선언문의 경우 '함수명'을 생략할 수 없다. 
// 함수명은 함수 몸체에서 자신을 재귀적(Recursive)호출하거나 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자이다.

// (2) 매개변수 목록
// 0개 이상의 목록으로, 괄호로 감싸고 콤마로 분리한다. 
// (다른 언어와의 차이점은 매개변수의 타입을 기술하지 않는다는 것이다.)
// 함수 몸체 내에서 매개변수의 타입 체크가 필요할 수 있다.

// (3) 함수 몸체
// 함수가 호출되었을 때 실행되는 문들의 집합이다.
// ({}) 중괄호로 감싸고 return문으로 결과값을 반화할 수 있다. = 이를 '반환 값' 이라 한다.

// 함수 선언문 (Function declaration)
function 함수명(매개변수) {
    return "반환값을돌려줘요";
}

/* 1.2 함수 표현식 */
// 자바스크립트의 함수는 일급 객체이므로 아래와 같은 특징이 있다.
// - 무명의 리터럴로 표현이 가능하다.
// - 변수나 자료 구조(객체, 배열)에 저장할 수 있다.
// - 함수의 파라미터로 전달할 수 있다.
// - 반환값으로도 사용할 수 있다. 


// 함수 표현식 (Function expression)
// 함수의 일급객체 특성을 이용하여 '함수 리터럴 방식'으로 함수를 정의하고, '변수에 할당'할 수 있다.
var square = function(num) {
    return num * num;
}

    // 함수 표현식에서 함수명 생략한 익명 함수 (anonymous function)
    // 함수 표현식에서는 함수명을 생략하는 익명 함수로 쓰는 것이 일반적이다.

    // 기명 함수 표현식 (named function expression)
    var foo = function multiply(a, b) {
        return a * b;
    };

    // 익명 함수 표현식 (anonymous function expression)
    var bar = function(a, b) {
        return a * b;
    };

console.log(foo(10, 5)); // 50
// console.log(multiply(10, 5)); // Uncaught ReferenceError: multiply is not defined at ~
// 함수는 일급객체이기 때문에 변수에 할당할 수 있는데, 이 변수는 함수명이 아니라서 할당된 함수를 가리키는 참조값을 저장한다.
// 함수 호출시 함수를 가리키는 변수명을 사용해야 한다.
console.log(bar(10, 5)); // 50

var originFunc = function(a, b){
    return a * b;
};
var refFunc = originFunc;
console.log(originFunc(10, 10)); 
console.log(refFunc(10, 2));
// 위의 코드에서 originFunc와 refFunc는 동일한 익명함수를 참조한다. (동일한 익명함수의 참조값을 갖는다.)
// 함수가 할당된 변수를 사용해 함수를 호출하지 않고, 기명 함수의 함수명을 사용해 호출하면 에러가 발생한다. (-> 89L)
// 이는 함수 표현식에서 사용한 함수명은 외부 코드에서 접근이 불가능하기 때문이다.

// 함수 표현식과 함수 선언문에서 사용한 함수명의 사용처
// - 함수 몸체에서 자신을 재귀적 호출 하거나, 
// - 자바스크립트 디버거가 해당 함수를 구분할 수 있는 식별자의 역할을 한다.
// 함수 선언문의 경우, 함수명으로 호출할 수 있었는데 이건 js 엔진에 의해서 아래와 같은 함수 표현식으로 형태가 변경되기 때문이다.
function add(a, b){
    return a + b;
}; // 함수 선언문
// 사실 이 친구의 본 모습은

var add = function add(a, b){
    return a + b;
};
// 함수 표현식이다. 
// 함수명(우)과 함수 참조값을 가진 변수명(좌)이 일치하므로 함수명으로 호출되는 듯 보이지만 사실은 변수명(좌)으로 호출된 것이다. 



/* 1.3 Function 생성자 함수 */
// 함수 표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용하죠
// 함수 선언문도 내부적으로 자바스크립트 엔진이 기명 함수 표현식으로 변환하므로 결국 함수 리터럴 방식을 이용한다.

// 따라서, 함수 선언문과 함수 표현식은 모두 함수 리터럴 방식으로 함수를 정의하는데,
// 이것은 결국 내장 함수 Function 생성자 함수로 
// 함수를 생성하는 것을 단순화 시킨 Short-hand (축약법) 이다.

// Function 생성자 함수는 Function.prototype.constructor 프로퍼티로 접근할 수 있다.
// Function 생성자 함수로 함수를 생성하는 문법은 아래와 같다.
// new Function(arg1, arg2, ... argN, functionBody)
var square = new Function('number', 'return number * number');
console.log(square(10));
// 하지만 Function 생성자 함수로 함수를 생성하는 방식은 일반적으로 사용하지 않는다.




/* 2. 함수 호이스팅 */
// 3가지의 함수 정의 방식은 동작 방식에서 약간의 차이가 있다.

// 2-1. 함수 선언문은 함수가 정의되기 전에 함수 호출할 수 있다. -> 호이스팅 때문.
var res = divide(10, 5); // 함수가 정의되기 전에 호출되었다. 
console.log(res); 

function divide(number1, number2) { // 함수 선언문 정의
    return number1 / number2;
};
// 위 코드는 함수 선언문.
// 함수가 정의되기 전에 함수 호출이 가능하다.
// 함수 선언문의 경우, 함수 선언 위치와 상관없이 코드 내 어느 곳에서 호출이 가능하다 bc. 호이스팅

// [*] 자바스크립트는 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅한다.
// [호이스팅]이란? var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다.
// 즉, 자바스크립트는 모든 선언문이 선언되기 전에 참조 가능하다. 

// 더 자세히,
// 함수 선언문으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에서 바로 초기화하고 이를 VO에 저장한다. 
// 즉, 함수 선언, 초기화, 할당이 한번에 이루어진다.
// 그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느곳에서든지 호출이 가능하다.

// 2-2. 함수 표현식은 정의 후에 호출해야 한다.
// 함수 표현식은 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.
// var errExp = expFunc(5); // TypeError: expFunc is not a function
// console.log(errExp)
// var expFunc = function(number) {
//     return number * number;
// }

// 함수 표현식의 경우 TypeError를 발생한다. 함수 호이스팅이 아닌 '변수 호이스팅'이 발생하기 때문.
// [변수 호이스팅]은 변수 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 'undefined로 초기화'되고 '실제값의 할당은 할당문에서' 이루어진다.
// 아무튼 그래서 함수 표현식은 함수 선언문과 달리 스크립트 로딩 시점에 변수 객체에 함수를 할당하지 않고, 런타임에 해석되고 실행되므로 두가지를 구분하는 것이 중요하다.



/* 3. First-class object (일급 객체) */
// 일급 객체란 생성, 대입, 연산, 인자 또는 반환값으로써의 전달 등 프로그래밍 언어의 기본적 조작을 제한없이 사용할 수 있는 대상을 의미함.
// 다음을 만족하면 일급 객체이다.
// 1) 무명의 리터럴로 표현이 가능하다.
// 2) 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
// 3) 함수의 매개변수에 전달할 수 있다.
// 4) 반환값으로 사용할 수 있다.

// 예시코드
// 1) 무명의 리터럴로 표현이 가능하다.
// 2) 변수나 자료 구조(객체, 배열 등)에 저장할 수 있다.
var increase = function(num) {
    return ++num;
};

var decrease = function(num) {
    return --num;
};

var predicates = { increase, decrease }

// 3) 함수의 매개변수에 전달할 수 있다.
// 4) 반환값으로 사용할 수 있다.
function makeCounter(predicate) {
    var num = 0;
    
    return function() {
        num = predicate(num);
        return num;
    };
}

var increaser = makeCounter(predicates.increase);
console.log(increaser());
console.log(increaser());

var decreaser = makeCounter(predicates.decrease);
console.log(decreaser());
console.log(decreaser());






var 증가 = function(num) {
    return ++num;
};
var 감소 = function(num) {
    return --num;
};

var 함수들 = {증가, 감소};

function 카운터를만들어보자(매개함수) {
    var num = 0;
    
    return function() {
        console.log('num' + num)
        num = 매개함수(num);
        return num;
    };
};

var 증가하는놈 = 카운터를만들어보자(함수들.증가);
console.log(증가하는놈());
console.log(증가하는놈());
console.log(증가하는놈());























////////////////////////////////////////////////////////////////////////////////
/* 함수 선언문과 함수 표현식의 호이스팅 예제 */
// decFunc(); // 출력 됨.
// expFunc(); // expFunc is not a function

// function decFunc() {
//     console.log("함수 선언문은 호이스팅 되어서 함수를 선언하기 전에 호출이 가능하다.");
// }

// var expFunc = function() {
//     console.log("변수에 할당된 함수 표현식은 변수명만 끌어올라가져서 함수는 실행되지 않는다.");
// }

// /* 위 코드를 JS Parser 내부의 호이스팅 결과를 나타냈다. */
// var expFunc; // [Hoisting] 함수 표현식의 변수값 "선언"
// function decFunc() { // [Hoisiting] 함수 선언문
//     console.log("함수 선언문은 호이스팅 되어서 함수를 선언하기 전에 호출이 가능하다.");
// }

// decFunc(); 
// expFunc(); // ERROR!

// expFunc = function() {
//     console.log("변수에 할당된 함수 표현식은 변수명만 끌어올라가져서 함수는 실행되지 않는다.");
// }
////////////////////////////////////////////////////////////////////////////////


// [함수 표현식에서의 호이스팅]
// 
// 1) 함수 표현식의 선언이 호출보다 위에 있는 경우 - 정상 출력
// function printName(firstname) { // 함수 선언문
//     var inner = function () { // 함수 표현식 "선언"
//         return "inner value";
//     }
//     var result = inner(); // 함수 "호출"
//     console.log("name is " + result);
// };
// printName(); 
// 위의 코드를 호이스팅 해보자
// function printName(firstname) {
//     var inner; // h 함수 표현식의 변수명 선언
//     var result; // h var 변수명

//     inner = function() {
//         return "inner value";
//     };

//     result = inner();
//     console.log("name is " + result);
// };
// printName();
//
// 2) 함수 표현식이 선언보다 아래에 있는 경우 - TypeError : inner is not a function 
// function printName(firstname) {
//     console.log(inner); // undefined

//     var result = inner(); 

//     var inner = function() {
//         return "inner value";
//     }
// }
// printName(); // TypeError : inner is not a function 

// inner가 undefined로 나오는 이유는, 선언이 되면 undefined로 지정되기 떄문.
// 즉 이 말은 아직 함수로 인식이 되지 않았다는 것을 의미한다.
// 위 코드를 호이스팅








/* 즉시실행함수와 This */
var A = {
    foo: 1
}; // <- 꼭 세미콜론으로 닫아주자. Uncaught TypeError: {(intermediate value)} is not a function.

(function() {console.log(this)})(); 
// 즉시실행함수는 코드에서 즉시 실행해버린다. 실행하는 주체가 없으므로 상위로 계속 올라가다 보면 Window가 나옴.
// 결론은 이 코드에서 this는 Window 객체를 가리킨다. 
// > Window

// this scope는 함수를 실행시키는 주체(객체)를 가리킨다. 
// 이 this도 명시적으로 바꿔줄 수 있다 => bind, call, apply를 활용한다.
// 바꿔보자.
(function() {console.log(this)}.bind(A))();
// > {foo: 1}

</script>
</body>
</html>